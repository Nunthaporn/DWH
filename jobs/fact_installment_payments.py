from dagster import op, job
import pandas as pd
import numpy as np
import os
import re
from datetime import datetime
from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy import create_engine, MetaData, Table, inspect
from sqlalchemy.dialects.postgresql import insert as pg_insert

# ‚úÖ Load env
load_dotenv()

# ‚úÖ DB connections
source_engine = create_engine(
    f"mysql+pymysql://{os.getenv('DB_USER')}:{os.getenv('DB_PASSWORD')}@{os.getenv('DB_HOST')}:{os.getenv('DB_PORT')}/fininsurance"
)
task_engine = create_engine(
    f"mysql+pymysql://{os.getenv('DB_USER')}:{os.getenv('DB_PASSWORD')}@{os.getenv('DB_HOST')}:{os.getenv('DB_PORT')}/fininsurance_task"
)
target_engine = create_engine(
    f"postgresql+psycopg2://{os.getenv('DB_USER_test')}:{os.getenv('DB_PASSWORD_test')}@{os.getenv('DB_HOST_test')}:{os.getenv('DB_PORT_test')}/fininsurance"
)

@op
def extract_installment_data():
    # ‚úÖ ‡πÉ‡∏ä‡πâ context manager ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ connection ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
    try:
        df_plan = pd.read_sql("""
            SELECT quo_num
            FROM fin_system_select_plan
            WHERE datestart >= '2025-01-01' AND datestart < '2025-07-01'
            AND type_insure IN ('‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô‡∏£‡∏ñ', '‡∏ï‡∏£‡∏≠')
        """, source_engine)

        df_installment = pd.read_sql("""
            SELECT quo_num, money_one, money_two, money_three, money_four,
                   money_five, money_six, money_seven, money_eight, money_nine,
                   money_ten, money_eleven, money_twelve,
                   date_one, date_two, date_three, date_four, date_five,
                   date_six, date_seven, date_eight, date_nine, date_ten,
                   date_eleven, date_twelve, numpay
            FROM fin_installment
        """, source_engine)

        df_order = pd.read_sql("""
            SELECT quo_num, order_number
            FROM fin_order
            WHERE type_insure IN ('‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô‡∏£‡∏ñ', '‡∏ï‡∏£‡∏≠')
        """, task_engine)

        df_finance = pd.read_sql("""
            SELECT order_number, datepay_one, datepay_two, datepay_three, datepay_four,
                   datepay_five, datepay_six, datepay_seven, datepay_eight,
                   datepay_nine, datepay_ten, datepay_eleven, datepay_twelve,
                   moneypay_one, moneypay_two, moneypay_three, moneypay_four,
                   moneypay_five, moneypay_six, moneypay_seven, moneypay_eight,
                   moneypay_nine, moneypay_ten, moneypay_eleven, moneypay_twelve,
                   numpay
            FROM fin_finance
            WHERE order_number REGEXP '[A-Z]+25[0-9]{2}-[0-9]+'
        """, task_engine)

        df_bill = pd.read_sql("""
            SELECT order_number, bill_receipt, bill_receipt2, bill_receipt3,
                   bill_receipt4, bill_receipt5, bill_receipt6, bill_receipt7,
                   bill_receipt8, bill_receipt9, bill_receipt10, bill_receipt11, bill_receipt12
            FROM fin_bill
        """, task_engine)

        df_late_fee = pd.read_sql("""
            SELECT orderNumber, penaltyPay, numPay
            FROM FIN_Account_AttachSlip_PathImageSlip
            WHERE checkPay IN ('‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö', '‡∏Ñ‡πà‡∏≤‡∏á‡∏ß‡∏î/‡∏Ñ‡πà‡∏≤‡∏õ‡∏£‡∏±‡∏ö')
        """, task_engine)

        df_test = pd.read_sql("""
            SELECT quo_num
            FROM fin_system_select_plan
            WHERE name IN ('‡∏ó‡∏î‡∏™‡∏≠‡∏ö','test')
              AND type_insure IN ('‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô‡∏£‡∏ñ', '‡∏ï‡∏£‡∏≠')
        """, source_engine)
        
    except Exception as e:
        print(f"‚ùå Error during data extraction: {e}")
        # ‚úÖ Rollback connections ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ PendingRollbackError
        try:
            with source_engine.connect() as conn:
                conn.rollback()
        except:
            pass
        try:
            with task_engine.connect() as conn:
                conn.rollback()
        except:
            pass
        try:
            with target_engine.connect() as conn:
                conn.rollback()
        except:
            pass
        raise e

    # ‚úÖ Debug print
    print("üì¶ df_plan:", df_plan.shape)
    print("üì¶ df_installment:", df_installment.shape)
    print("üì¶ df_order:", df_order.shape)
    print("üì¶ df_finance:", df_finance.shape)
    print("üì¶ df_bill:", df_bill.shape)
    print("üì¶ df_late_fee:", df_late_fee.shape)
    print("üì¶ df_test:", df_test.shape)

    return df_plan, df_installment, df_order, df_finance, df_bill, df_late_fee, df_test

@op
def clean_installment_data(inputs):
    df_plan, df_inst, df_order, df_fin, df_bill, df_fee, df_test = inputs

    # 1. ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡∏á‡∏ß‡∏î + ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà
    df_inst['numpay'] = pd.to_numeric(df_inst['numpay'], errors='coerce')
    df_filtered = df_inst[df_inst['numpay'].notna() & (df_inst['numpay'] > 0)]

    money_cols = [f'money_{n}' for n in ['one', 'two', 'three', 'four', 'five', 'six',
                                         'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve']]
    date_cols = [f'date_{n}' for n in ['one', 'two', 'three', 'four', 'five', 'six',
                                       'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve']]

    df_money = df_filtered.melt(id_vars=['quo_num', 'numpay'], value_vars=money_cols,
                                 var_name='installment_period', value_name='installment_amount')
    df_date = df_filtered.melt(id_vars=['quo_num', 'numpay'], value_vars=date_cols,
                                var_name='due_date_period', value_name='due_date')

    df_combined = pd.concat([df_money.reset_index(drop=True), df_date['due_date']], axis=1)
    df_combined['installment_number'] = df_combined.groupby('quo_num').cumcount() + 1
    df_combined = df_combined[df_combined['installment_number'] <= df_combined['numpay']]
    df_combined = df_combined.sort_values(by=['quo_num', 'due_date'])
    df_combined['installment_number'] = df_combined.groupby('quo_num').cumcount() + 1

    # 2. ‡∏ú‡∏π‡∏Å order_number
    df_join = pd.merge(df_combined, df_order, on='quo_num', how='left')

    # 3. ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞
    num_to_name = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight',
                   'nine', 'ten', 'eleven', 'twelve']
    
    df_fin['numpay'] = pd.to_numeric(df_fin['numpay'], errors='coerce')
    df_fin = df_fin[df_fin['numpay'].notna() & (df_fin['numpay'] > 0)]

    # ‡πÉ‡∏ä‡πâ vectorized operations ‡πÅ‡∏ó‡∏ô iterrows()
    rows_list = []
    for i, sfx in enumerate(num_to_name, start=1):
        money_col = f'moneypay_{sfx}'
        date_col = f'datepay_{sfx}'
        
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á DataFrame ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ installment
        temp_df = df_fin[['order_number', money_col, date_col]].copy()
        temp_df['installment_number'] = i
        temp_df['payment_amount'] = temp_df[money_col]
        
        # ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà
        temp_df['raw_date'] = temp_df[date_col].astype(str)
        temp_df['payment_date'] = pd.to_datetime(
            temp_df['raw_date'].str.extract(r'(\d{4}-\d{1,2}-\d{1,2})')[0], 
            errors='coerce'
        )
        
        # ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏õ‡∏µ 2026 ‡πÄ‡∏õ‡πá‡∏ô 2025 - ‡πÉ‡∏ä‡πâ vectorized operations
        mask_2026 = temp_df['payment_date'].dt.year == 2026
        if mask_2026.any():
            # ‡πÉ‡∏ä‡πâ pd.to_datetime() ‡πÅ‡∏ó‡∏ô apply
            temp_df.loc[mask_2026, 'payment_date'] = pd.to_datetime(
                temp_df.loc[mask_2026, 'payment_date'].dt.strftime('2025-%m-%d'),
                errors='coerce'
            )
        
        rows_list.append(temp_df[['order_number', 'payment_amount', 'payment_date', 'installment_number']])

    df_payment = pd.concat(rows_list, ignore_index=True)

    # 4. ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° payment proof
    df_proof = df_bill.melt(id_vars=['order_number'],
        value_vars=[f'bill_receipt{i if i > 1 else ""}' for i in range(1, 13)],
        value_name='payment_proof')
    df_proof = df_proof[df_proof['payment_proof'].notna()].reset_index()
    df_proof['installment_number'] = df_proof.groupby('order_number').cumcount() + 1
    df_proof = df_proof[['order_number', 'installment_number', 'payment_proof']]

    # 5. ‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    df = pd.merge(df_join, df_payment, on=['order_number', 'installment_number'], how='left')
    df = pd.merge(df, df_proof, on=['order_number', 'installment_number'], how='left')

    df.loc[
        (df['installment_number'] == 1) & (df['payment_amount'].isna()),
        'payment_amount'
    ] = df['installment_amount']

    # 6. ‡πÄ‡∏û‡∏¥‡πà‡∏° late_fee
    df_fee = df_fee.rename(columns={
        'orderNumber': 'order_number',
        'penaltyPay': 'late_fee',
        'numPay': 'installment_number'
    })
    df_fee = df_fee.drop_duplicates()
    df['installment_number'] = pd.to_numeric(df['installment_number'], errors='coerce')
    df_fee['installment_number'] = pd.to_numeric(df_fee['installment_number'], errors='coerce')
    df = pd.merge(df, df_fee, on=['order_number', 'installment_number'], how='left')
    df['late_fee'] = df['late_fee'].fillna(0).astype(int)

    # 7. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì total_paid - ‡πÉ‡∏ä‡πâ vectorized operations ‡πÅ‡∏ó‡∏ô apply
    df['payment_amount'] = pd.to_numeric(df['payment_amount'], errors='coerce')
    df['installment_amount'] = pd.to_numeric(df['installment_amount'], errors='coerce')
    df['late_fee'] = pd.to_numeric(df['late_fee'], errors='coerce').fillna(0)
    
    # ‡πÉ‡∏ä‡πâ numpy.where ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö vectorized conditional logic
    import numpy as np
    
    # ‡∏ñ‡πâ‡∏≤ late_fee = 0 ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ installment_amount
    df['total_paid'] = np.where(
        df['late_fee'] == 0,
        df['installment_amount'].fillna(0),
        # ‡∏ñ‡πâ‡∏≤ late_fee != 0 ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ payment_amount + late_fee ‡∏´‡∏£‡∏∑‡∏≠ installment_amount + late_fee
        np.where(
            df['payment_amount'].notna(),
            df['payment_amount'] + df['late_fee'],
            df['installment_amount'].fillna(0) + df['late_fee']
        )
    )

    # 8. payment_status
    df['due_date'] = pd.to_datetime(df['due_date'], errors='coerce')
    df['payment_date'] = pd.to_datetime(df['payment_date'], errors='coerce')
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ï‡πà‡∏≤‡∏á‡πÜ
    no_payment = df['payment_amount'].isna() & df['payment_date'].isna() & df['payment_proof'].isna()
    has_payment = df['payment_amount'].notna() | df['payment_proof'].notna()
    has_due_date = df['due_date'].notna()
    has_payment_date = df['payment_date'].notna()
    is_overdue = has_due_date & (datetime.now().date() > df['due_date'].dt.date)
    is_late_payment = has_payment_date & has_due_date & (df['payment_date'].dt.date > df['due_date'].dt.date)
    
    # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î payment_status
    df['payment_status'] = '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ä‡∏≥‡∏£‡∏∞'  # ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    df.loc[no_payment & is_overdue, 'payment_status'] = '‡πÄ‡∏Å‡∏¥‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏≥‡∏£‡∏∞'
    df.loc[has_payment & ~is_late_payment, 'payment_status'] = '‡∏ä‡∏≥‡∏£‡∏∞‡πÅ‡∏•‡πâ‡∏ß'
    df.loc[has_payment & is_late_payment, 'payment_status'] = '‡∏ä‡∏≥‡∏£‡∏∞‡∏•‡πà‡∏≤‡∏ä‡πâ‡∏≤'

    # 9. ‡∏•‡πâ‡∏≤‡∏á test
    df = df[~df['quo_num'].isin(df_test['quo_num'])]
    df = df.rename(columns={'quo_num': 'quotation_num'})
    df['installment_number'] = df['installment_number'].replace({'0': '1'})
    df['installment_number'] = pd.to_numeric(df['installment_number'], errors='coerce')
    df['due_date'] = pd.to_datetime(df['due_date'], errors='coerce')
    df['due_date'] = df['due_date'].dt.strftime('%Y%m%d')
    df['payment_date'] = pd.to_datetime(df['payment_date'], errors='coerce')
    df['payment_date'] = df['payment_date'].dt.strftime('%Y%m%d')
    
    # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    print("üîç Before cleaning:")
    print(f"üìä Shape: {df.shape}")
    nan_counts_before = df.isna().sum()
    print("üìä NaN counts before cleaning:")
    for col, count in nan_counts_before.items():
        if count > 0:
            print(f"  - {col}: {count}")
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ sanitize_dataframe function ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏° - ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
    print("üßπ Applying comprehensive data sanitization...")
    df = sanitize_dataframe(df.copy())
    
    # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    print("‚úÖ After cleaning:")
    print(f"üìä Shape: {df.shape}")
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö NaN values ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠
    nan_counts_after = df.isna().sum()
    print("üìä NaN counts after cleaning:")
    for col, count in nan_counts_after.items():
        if count > 0:
            print(f"  - {col}: {count}")
    
    # ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏£‡∏∏‡∏õ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á
    print("\nüìä Cleaning completed")
    for col in df.columns:
        if col in nan_counts_before.index and col in nan_counts_after.index:
            before = nan_counts_before[col]
            after = nan_counts_after[col]
            if before != after:
                print(f"  - {col}: {before} ‚Üí {after} NaN values")

    return df

def sanitize_dataframe(df: pd.DataFrame) -> pd.DataFrame:
    """‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤ 'NaN', 'null', 'none' string ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô None ‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á float NaN ‡πÄ‡∏õ‡πá‡∏ô None - ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û"""
    
    # üîÅ ‡∏™‡∏£‡πâ‡∏≤‡∏á copy ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
    df_clean = df.copy()
    
    # üîÅ ‡πÅ‡∏õ‡∏•‡∏á float NaN ‡πÄ‡∏õ‡πá‡∏ô None ‡∏Å‡πà‡∏≠‡∏ô
    df_clean = df_clean.where(pd.notna(df_clean), None)
    
    # üîÅ ‡∏•‡πâ‡∏≤‡∏á string columns ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
    string_columns = df_clean.select_dtypes(include=['object']).columns
    
    for col in string_columns:
        if col in df_clean.columns:
            # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô string ‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡πÉ‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
            df_clean[col] = df_clean[col].astype(str)
            
            # ‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
            nan_mask = (
                df_clean[col].str.lower().isin(['nan', 'null', 'none', 'nonetype', 'nulltype']) |
                df_clean[col].str.strip().isin(['', '[null]']) |
                df_clean[col].str.contains('^\\[null\\]$', case=False, na=False)
            )
            
            # ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡πà‡∏≤ NaN string ‡∏î‡πâ‡∏ß‡∏¢ None
            df_clean.loc[nan_mask, col] = None
            
            # ‡∏•‡∏ö whitespace ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà None
            mask_not_none = df_clean[col].notna()
            if mask_not_none.any():
                df_clean.loc[mask_not_none, col] = df_clean.loc[mask_not_none, col].str.strip()
                
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å strip
                nan_mask_after = (
                    df_clean[col].str.lower().isin(['nan', 'null', 'none', '']) |
                    df_clean[col].str.contains('^\\[null\\]$', case=False, na=False)
                )
                df_clean.loc[nan_mask_after, col] = None

    # üîÅ ‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏°‡∏µ comma - ‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô
    numeric_cols = ['installment_amount', 'payment_amount', 'total_paid', 'late_fee']
    for col in numeric_cols:
        if col in df_clean.columns:
            # ‡∏•‡∏ö comma ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ cell ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô string ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà None
            mask_string = df_clean[col].astype(str).str.contains(',', na=False)
            if mask_string.any():
                df_clean.loc[mask_string, col] = df_clean.loc[mask_string, col].astype(str).str.replace(',', '')
            
            # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô numeric
            df_clean[col] = pd.to_numeric(df_clean[col], errors='coerce')
            # ‡πÅ‡∏õ‡∏•‡∏á NaN ‡πÄ‡∏õ‡πá‡∏ô None
            df_clean[col] = df_clean[col].where(pd.notna(df_clean[col]), None)

    return df_clean

@op
def load_installment_data(df: pd.DataFrame):
    table_name = 'fact_installment_payments'
    pk_column = 'quotation_num'

    # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô
    print("üîç Before database operations:")
    print(f"üìä DataFrame shape: {df.shape}")
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö NaN values ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
    nan_counts = df.isna().sum()
    print("üìä NaN counts before DB operations:")
    for col, count in nan_counts.items():
        if count > 0:
            print(f"  - {col}: {count}")
    
    # ‚úÖ ‡πÉ‡∏ä‡πâ sanitize_dataframe function ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏° - ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
    print("üßπ Applying comprehensive data sanitization...")
    df = sanitize_dataframe(df.copy())
    
    # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    print("‚úÖ After sanitization:")
    nan_counts_after = df.isna().sum()
    print("üìä NaN counts after sanitization:")
    for col, count in nan_counts_after.items():
        if count > 0:
            print(f"  - {col}: {count}")

    # ‚úÖ ‡∏Å‡∏£‡∏≠‡∏á fact_installment_payments ‡∏ã‡πâ‡∏≥‡∏à‡∏≤‡∏Å DataFrame ‡πÉ‡∏´‡∏°‡πà
    df = df[~df[pk_column].duplicated(keep='first')].copy()

    # ‚úÖ Load ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡∏à‡∏≤‡∏Å PostgreSQL
    try:
        with target_engine.connect() as conn:
            df_existing = pd.read_sql(f"SELECT * FROM {table_name}", conn)
    except Exception as e:
        print(f"‚ùå Error loading existing data: {e}")
        # ‚úÖ Rollback connection
        try:
            with target_engine.connect() as conn:
                conn.rollback()
        except:
            pass
        raise e

    # ‚úÖ ‡∏Å‡∏£‡∏≠‡∏á fact_installment_payments ‡∏ã‡πâ‡∏≥‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤
    df_existing = df_existing[~df_existing[pk_column].duplicated(keep='first')].copy()

    # ‚úÖ Identify fact_installment_payments ‡πÉ‡∏´‡∏°‡πà (‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏ô DB)
    new_ids = set(df[pk_column]) - set(df_existing[pk_column])
    df_to_insert = df[df[pk_column].isin(new_ids)].copy()

    # ‚úÖ Identify fact_installment_payments ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
    common_ids = set(df[pk_column]) & set(df_existing[pk_column])
    df_common_new = df[df[pk_column].isin(common_ids)].copy()
    df_common_old = df_existing[df_existing[pk_column].isin(common_ids)].copy()

    # ‚úÖ Merge ‡∏î‡πâ‡∏ß‡∏¢ suffix (_new, _old)
    merged = df_common_new.merge(df_common_old, on=pk_column, suffixes=('_new', '_old'))

    # ‚úÖ ‡∏£‡∏∞‡∏ö‡∏∏‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö (‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô key ‡πÅ‡∏•‡∏∞ audit fields)
    exclude_columns = [pk_column, 'installment_id', 'create_at', 'update_at']
    compare_cols = [
        col for col in df.columns
        if col not in exclude_columns
        and f"{col}_new" in merged.columns
        and f"{col}_old" in merged.columns
    ]

    # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏´‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏à‡∏£‡∏¥‡∏á - ‡πÉ‡∏ä‡πâ vectorized operations ‡πÅ‡∏ó‡∏ô apply
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á mask ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
    diff_mask = pd.Series([False] * len(merged), index=merged.index)
    
    for col in compare_cols:
        col_new = f"{col}_new"
        col_old = f"{col}_old"
        
        # ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
        col_diff = (merged[col_new] != merged[col_old]) & (
            merged[col_new].notna() | merged[col_old].notna()
        )
        diff_mask = diff_mask | col_diff
    
    df_diff = merged[diff_mask].copy()

    # ‚úÖ ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° DataFrame ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö update ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ fact_installment_payments ‡∏õ‡∏Å‡∏ï‡∏¥ (‡πÑ‡∏°‡πà‡πÄ‡∏ï‡∏¥‡∏° _new)
    update_cols = [f"{col}_new" for col in compare_cols]
    all_cols = [pk_column] + update_cols

    df_diff_renamed = df_diff[all_cols].copy()
    df_diff_renamed.columns = [pk_column] + compare_cols  # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠ column ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏à‡∏£‡∏¥‡∏á

    print(f"üÜï Insert: {len(df_to_insert)} rows")
    print(f"üîÑ Update: {len(df_diff_renamed)} rows")

    # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏≤‡∏£ insert/update - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    if not df_to_insert.empty:
        print("üîç Checking insert data:")
        insert_nan_counts = df_to_insert.isna().sum()
        for col, count in insert_nan_counts.items():
            if count > 0:
                print(f"  - {col}: {count} NaN values")
        
        # ‚úÖ ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• insert ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
        print("üßπ Sanitizing insert data...")
        df_to_insert = sanitize_dataframe(df_to_insert.copy())
    
    if not df_diff_renamed.empty:
        print("üîç Checking update data:")
        update_nan_counts = df_diff_renamed.isna().sum()
        for col, count in update_nan_counts.items():
            if count > 0:
                print(f"  - {col}: {count} NaN values")
        
        # ‚úÖ ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• update ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
        print("üßπ Sanitizing update data...")
        df_diff_renamed = sanitize_dataframe(df_diff_renamed.copy())

    # ‚úÖ Load table metadata
    metadata = Table(table_name, MetaData(), autoload_with=target_engine)

    # ‚úÖ Insert (‡∏Å‡∏£‡∏≠‡∏á fact_installment_payments ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô NaN)
    if not df_to_insert.empty:
        df_to_insert_valid = df_to_insert[df_to_insert[pk_column].notna()].copy()
        dropped = len(df_to_insert) - len(df_to_insert_valid)
        if dropped > 0:
            print(f"‚ö†Ô∏è Skipped {dropped}")
        if not df_to_insert_valid.empty:
            with target_engine.begin() as conn:
                conn.execute(metadata.insert(), df_to_insert_valid.to_dict(orient='records'))

    # ‚úÖ Update
    if not df_diff_renamed.empty:
        with target_engine.begin() as conn:
            for record in df_diff_renamed.to_dict(orient='records'):
                stmt = pg_insert(metadata).values(**record)
                update_columns = {
                    c.name: stmt.excluded[c.name]
                    for c in metadata.columns
                    if c.name != pk_column
                }
                stmt = stmt.on_conflict_do_update(
                    index_elements=[pk_column],
                    set_=update_columns
                )
                conn.execute(stmt)

    # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£ insert/update - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    print("üîç Checking data in database after operations:")
    try:
        with target_engine.connect() as conn:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ñ‡∏ß‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            total_rows = pd.read_sql(f"SELECT COUNT(*) as total FROM {table_name}", conn).iloc[0]['total']
            print(f"üìä Total rows in {table_name}: {total_rows}")
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö NaN values ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• - ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏´‡∏•‡∏±‡∏Å
            key_columns = ['quotation_num', 'installment_number', 'order_number', 'payment_status']
            for col in key_columns:
                if col in df.columns:
                    null_count = pd.read_sql(f"SELECT COUNT(*) as null_count FROM {table_name} WHERE {col} IS NULL", conn).iloc[0]['null_count']
                    if null_count > 0:
                        print(f"  - {col}: {null_count} NULL values in database")
    except Exception as e:
        print(f"‚ùå Error in database check: {e}")
        # ‚úÖ Rollback connection
        try:
            with target_engine.connect() as conn:
                conn.rollback()
        except:
            pass
        raise e

    print("‚úÖ Insert/update completed.")
    
    # ‚úÖ ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ NaN strings) - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    print("üßπ Cleaning existing data in database...")
    with target_engine.begin() as conn:
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        column_info_query = f"""
        SELECT column_name, data_type 
        FROM information_schema.columns 
        WHERE table_name = '{table_name}'
        ORDER BY ordinal_position
        """
        column_info = pd.read_sql(column_info_query, conn)
        
        # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤ NaN strings ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô NULL (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå string)
        update_queries = []
        for col in df.columns:
            col_info = column_info[column_info['column_name'] == col]
            if not col_info.empty:
                data_type = col_info.iloc[0]['data_type']
                
                if data_type in ['character varying', 'text', 'character']:
                    update_query = f"""
                    UPDATE {table_name} 
                    SET {col} = NULL 
                    WHERE {col} IN ('nan', 'NaN', 'NAN', 'null', 'NULL', 'Null', 'none', 'None', 'NONE', '[null]', '[NULL]', '[Null]')
                    OR {col} = ''
                    """
                    update_queries.append(update_query)
        
        # ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï
        for query in update_queries:
            try:
                result = conn.execute(query)
                if result.rowcount > 0:
                    print(f"  ‚úÖ Updated {result.rowcount} rows with NaN strings")
            except Exception as e:
                print(f"  ‚ö†Ô∏è Warning: Could not update some rows: {e}")
    
    # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    print("üîç Final check of data in database after cleaning:")
    try:
        with target_engine.connect() as conn:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ñ‡∏ß‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            total_rows = pd.read_sql(f"SELECT COUNT(*) as total FROM {table_name}", conn).iloc[0]['total']
            print(f"üìä Total rows in {table_name}: {total_rows}")
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö NaN values ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• - ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏´‡∏•‡∏±‡∏Å
            key_columns = ['quotation_num', 'installment_number', 'order_number', 'payment_status']
            for col in key_columns:
                if col in df.columns:
                    null_count = pd.read_sql(f"SELECT COUNT(*) as null_count FROM {table_name} WHERE {col} IS NULL", conn).iloc[0]['null_count']
                    if null_count > 0:
                        print(f"  - {col}: {null_count} NULL values in database")
    
    except Exception as e:
        print(f"‚ùå Error in final database check: {e}")
        # ‚úÖ Rollback connection
        try:
            with target_engine.connect() as conn:
                conn.rollback()
        except:
            pass
        raise e

@job
def fact_installment_payments_etl():
    load_installment_data(clean_installment_data(extract_installment_data()))

if __name__ == "__main__":
    try:
        # ‚úÖ Unpack tuple
        df_plan, df_installment, df_order, df_finance, df_bill, df_late_fee, df_test = extract_installment_data()
        
        # ‚úÖ Pass as tuple to cleaning function
        df_clean = clean_installment_data((df_plan, df_installment, df_order, df_finance, df_bill, df_late_fee, df_test))
        
        # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô
        print("üîç Before database operations:")
        print(f"üìä DataFrame shape: {df_clean.shape}")
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö NaN values ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
        nan_counts_csv = df_clean.isna().sum()
        print("üìä NaN counts before DB operations:")
        for col, count in nan_counts_csv.items():
            if count > 0:
                print(f"  - {col}: {count}")
        
        # ‚úÖ ‡πÉ‡∏ä‡πâ sanitize_dataframe function ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏° - ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
        print("üßπ Applying comprehensive data sanitization...")
        df_clean = sanitize_dataframe(df_clean.copy())
        
        # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î - ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
        print("‚úÖ After sanitization:")
        nan_counts_after = df_clean.isna().sum()
        print("üìä NaN counts after sanitization:")
        for col, count in nan_counts_after.items():
            if count > 0:
                print(f"  - {col}: {count}")

        load_installment_data(df_clean)
        print("üéâ completed! Data upserted to fact_installment_payment.")
        
    except Exception as e:
        print(f"‚ùå Error in main execution: {e}")
        # ‚úÖ Rollback connections ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ PendingRollbackError
        try:
            with source_engine.connect() as conn:
                conn.rollback()
        except:
            pass
        try:
            with task_engine.connect() as conn:
                conn.rollback()
        except:
            pass
        try:
            with target_engine.connect() as conn:
                conn.rollback()
        except:
            pass
        raise e
    
